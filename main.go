/*
Author: Oliver McLane

This program is a console-based Malware Analysis tool written in Go. It provides several options, including scanning a file locally, testing a preset malicious-file hash, and searching for information about a known hash.

The main functionality includes:
1. Analyzing a local file for malware using the MalwareAnalysis package.
2. Retrieving malware samples from the MalwareBazaar API based on SHA256 hash values using the MalwareSamples package.
3. Displaying analysis results, including verdict, threat level, Mitre Attacks, and signatures.
4. Searching for information about a known file hash.

Please make sure to set the API key (apiKey variable) before running the program to access the MalwareAnalysis APIs.
*/
package main

import (
	"awesomeProject/MalwareAnalysis"
	"awesomeProject/MalwareSamples"
	"encoding/json"
	"fmt"
	"os"
)

// API key for accessing the MalwareAnalysis API
var apiKey = "API_KEY_GOES_HERE"

// MalwareHashes Array of preset malicious-file hash values
var MalwareHashes = [3]string{
	"094fd325049b8a9cf6d3e5ef2a6d4cc6a567d7d49c35f8bb8dd9e3c6acf3d78d",
	"c58cfa2e3215d17a6c4c6fe6d2ecd24528fbdb1b55a0c2a78e08bdda18b00fdb",
	"c962220f649ced285cce63d4fc3e9fddd5e7aca54526d4099533a558cdb6ae93",
}

func main() {
	if apiKey == "API_KEY_GOES_HERE" {
		fmt.Println("Configure MalwareAnalysis apiKey!")
	} else {
		var choice int

		// Display welcome message and options
		fmt.Println("Welcome to the Go Lang console-based Malware Analysis tool.")
		fmt.Println("There are several options to choose from:")

		// Handle user input and choices
		for {
			fmt.Println("Enter your choice: ")
			fmt.Println("1. Scan a file locally")
			fmt.Println("2. Scan a preset malicious-file hash")
			fmt.Println("3. Search for information about a known hash")
			fmt.Println("4. Exit")
			_, err := fmt.Scanln(&choice)
			if err != nil {
				fmt.Println("Invalid input. Please enter a number.")
				continue
			}

			switch choice {
			case 1:
				// Option to scan a file locally
				fmt.Println("Enter the path to the local file you want to analyze:")
				var localFilePath string
				_, err := fmt.Scanln(&localFilePath)
				if err != nil {
					fmt.Println("Error:", err)
					continue
				}

				// Open the local file
				localFile, err := os.Open(localFilePath)
				if err != nil {
					fmt.Println("Error opening local file:", err)
					continue
				}
				defer localFile.Close()

				// Call AnalyzeFile with the local file reader
				jsonResponse, err := MalwareAnalysis.AnalyzeFile(localFile, apiKey)
				if err != nil {
					fmt.Println("Error analyzing file:", err)
					continue
				}

				// Parse JSON response into AnalysisResponse
				var analysisResponse MalwareAnalysis.AnalysisResponse
				if err := json.Unmarshal([]byte(jsonResponse), &analysisResponse); err != nil {
					fmt.Println("Error parsing JSON:", err)
					continue
				}

				// Print analysis result
				fmt.Println("Verdict:", analysisResponse.Verdict)
				fmt.Println("Threat Level:", analysisResponse.ThreatLevel)
				fmt.Println("Type:", analysisResponse.Type)
				fmt.Println("VX Family:", analysisResponse.VX_Family)
				fmt.Println("Date of Analysis:", analysisResponse.DateAnalysis)

				// Print Mitre Attacks
				fmt.Println("Mitre Attacks:")
				for _, attack := range analysisResponse.MitreAttacks {
					fmt.Println("Tactic:", attack.Tactic)
					fmt.Println("Technique:", attack.Technique)
					fmt.Println("ATT&CK ID:", attack.AttckID)
				}

				// Print Signatures
				fmt.Println("Signatures:")
				for _, signature := range analysisResponse.Signatures {
					fmt.Println("Name:", signature.Name)
					fmt.Println("Threat Level:", signature.ThreatLevel)
					fmt.Println("Description:", signature.Description)
					fmt.Println("Category:", signature.Category)
					fmt.Println("Identifier:", signature.Identifier)
					fmt.Println("Type:", signature.Type)
					fmt.Println("Relevance:", signature.Relevance)
					fmt.Println("Origin:", signature.Origin)
					fmt.Println("ATT&CK ID:", signature.ATTCKID)
					fmt.Println("CAPEC ID:", signature.CAPECID)
					fmt.Println("ATT&CK ID Wiki:", signature.ATTCKIDWiki)
				}

			case 2:
				// Option to scan a preset malicious-file hash
				fmt.Println("Select a preset hash:")
				for i, hash := range MalwareHashes {
					fmt.Printf("%d. %s\n", i+1, hash)
				}

				fmt.Print("Enter the number of the hash or 0 to quit: ")
				var hashIndex int
				_, err := fmt.Scanln(&hashIndex)
				if hashIndex == 0 {
					continue
				}
				if err != nil || hashIndex < 1 || hashIndex > len(MalwareHashes) {
					fmt.Println("Invalid input. Please enter a valid number.")
					continue
				}

				// Retrieve selected hash from the preset list
				selectedHash := MalwareHashes[hashIndex-1]
				// Get malware sample using the hash
				sample, _ := MalwareSamples.GetMalwareSampleFromMalwareBazzar(selectedHash)

				// Call AnalyzeFile
				jsonResponse, err := MalwareAnalysis.AnalyzeFile(sample, apiKey)
				if err != nil {
					fmt.Println("Error analyzing file:", err)
					continue
				}

				// Parse JSON response into AnalysisResponse
				var analysisResponse MalwareAnalysis.AnalysisResponse
				if err := json.Unmarshal([]byte(jsonResponse), &analysisResponse); err != nil {
					fmt.Println("Error parsing JSON:", err)
					continue
				}

				// Print analysis result
				fmt.Println("Verdict:", analysisResponse.Verdict)
				fmt.Println("Threat Level:", analysisResponse.ThreatLevel)
				fmt.Println("Type:", analysisResponse.Type)
				fmt.Println("VX Family:", analysisResponse.VX_Family)
				fmt.Println("Date of Analysis:", analysisResponse.DateAnalysis)

				// Print Mitre Attacks
				fmt.Println("Mitre Attacks:")
				for _, attack := range analysisResponse.MitreAttacks {
					fmt.Println("Tactic:", attack.Tactic)
					fmt.Println("Technique:", attack.Technique)
					fmt.Println("ATT&CK ID:", attack.AttckID)
					fmt.Println()
				}

				// Print Signatures
				fmt.Println("Signatures:")
				for _, signature := range analysisResponse.Signatures {
					fmt.Println("Name:", signature.Name)
					fmt.Println("Threat Level:", signature.ThreatLevel)
					fmt.Println("Description:", signature.Description)
					fmt.Println("Category:", signature.Category)
					fmt.Println("Identifier:", signature.Identifier)
					fmt.Println("Type:", signature.Type)
					fmt.Println("Relevance:", signature.Relevance)
					fmt.Println("Origin:", signature.Origin)
					fmt.Println("ATT&CK ID:", signature.ATTCKID)
					fmt.Println("CAPEC ID:", signature.CAPECID)
					fmt.Println("ATT&CK ID Wiki:", signature.ATTCKIDWiki)
					fmt.Println()
				}

			case 3:
				// Option to search for information about a known hash
				fmt.Print("Enter a valid file hash to search malware results: ")
				var searchedHash string
				fmt.Scanln(&searchedHash)
				responseJSON, err := MalwareAnalysis.DetailsHash(searchedHash, apiKey)
				if err != nil {
					continue
				}

				var hashResponses []MalwareAnalysis.HashResponse
				if err := json.Unmarshal([]byte(responseJSON), &hashResponses); err != nil {
					fmt.Println("Invalid or not analyzed hash. Try a valid file hash.")
					continue
				}
				var hashResponse = hashResponses[0]

				// Print hash report
				fmt.Println("Report for hash:", searchedHash)
				fmt.Println("Verdict:", hashResponse.Verdict)
				fmt.Println("Threat Level:", hashResponse.ThreatLevel)
				fmt.Println("File Type:", hashResponse.Type)
				fmt.Println("VX Family:", hashResponse.VX_Family)

				fmt.Println()
				fmt.Println("Mitre Framework")
				// Print Mitre Attacks
				for _, attack := range hashResponses[0].MitreAttacks {
					fmt.Println("Tactic:", attack.Tactic)
					fmt.Println("Technique:", attack.Technique)
					fmt.Println("Attack ID:", attack.AttckID)
					fmt.Println()
				}

			case 4:
				// Exit the program
				fmt.Println("Exiting...")
				return

			default:
				fmt.Println("Invalid choice. Please enter a valid option.")
			}
		}
	}
}
