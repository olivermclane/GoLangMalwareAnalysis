/*
Package MalwareSamples provides functions for retrieving malware samples from external sources and processing them.
The function GetMalwareSampleFromMalwareBazzar retrieves malware samples from the MalwareBazaar API based on SHA256 hash values.
Author: Oliver McLane
*/

package MalwareSamples

import (
	"bytes"
	"errors"
	"github.com/alexmullins/zip"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
)

// GetMalwareSampleFromMalwareBazzar pipes malware from an external source into the application for Proof of Concept (POC).
func GetMalwareSampleFromMalwareBazzar(sha256_hash string) (file io.Reader, err error) {
	// Base URL and query parameters for the MalwareBazaar API
	baseURL := "https://mb-api.abuse.ch/api/v1/"
	queryParams := url.Values{
		"query":       []string{"get_file"},
		"sha256_hash": []string{sha256_hash},
	}

	// Encode query parameters as form data
	formData := bytes.NewBufferString(queryParams.Encode())

	// Send POST request to MalwareBazaar API
	resp, err := http.Post(baseURL, "application/x-www-form-urlencoded", formData)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	// Check if the API responds with a successful status code
	if resp.StatusCode != http.StatusOK {
		return nil, errors.New("unable to pull malware file")
	}

	// Read the response body into a byte slice
	bodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	// Create a bytes.Reader from the byte slice
	bodyReader := bytes.NewReader(bodyBytes)
	// Unzip the response body using the password "infected"
	unzippedBody, err := unzip(bodyReader)
	if err != nil {
		return nil, err
	}

	return unzippedBody, nil
}

// unzip unzips the provided reader
func unzip(zippedBody io.Reader) (unzippedBody io.Reader, err error) {
	// Copy the zipped body to a buffer
	var buf bytes.Buffer
	_, err = io.Copy(&buf, zippedBody)
	if err != nil {
		return nil, err
	}

	// Open the zip archxive
	r, err := zip.NewReader(bytes.NewReader(buf.Bytes()), int64(buf.Len()))
	if err != nil {
		return nil, err
	}

	// Iterate through each file in the zip archive
	for _, f := range r.File {
		// Check if the file is encrypted
		if f.IsEncrypted() {
			// Set password for the encrypted file
			f.SetPassword("infected")
		}

		// Open the file inside the zip archive
		rc, err := os.OpenFile(f.Name, os.O_RDONLY, 0444)
		if err != nil {
			return nil, err
		}
		defer func(rc *os.File) {
			err := rc.Close()
			if err != nil {

			}
		}(rc)

		// Read the file's contents into a buffer
		var fileBuf bytes.Buffer
		_, err = io.Copy(&fileBuf, rc)
		if err != nil {
			return nil, err
		}

		// Return the buffer as an io.Reader
		return &fileBuf, nil
	}

	// If no files are found, return an error
	return nil, errors.New("no files found in the zip archive")
}
